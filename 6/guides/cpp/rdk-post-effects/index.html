<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>RDK Post Effect Classes with C/C++</title>
  <meta name="description" content="This document describes how to use the RDK's post effect classes in C/C++.  Using C/C++">

  <!-- OpenGraph for Facebook, Twitter, Slack unfurling -->
  <meta property="og:type" content="website" />
  <meta property="og:url" content="/guides/cpp/rdk-post-effects/" />
  <meta property="og:title" content="RDK Post Effect Classes" />
  <meta property="og:description" content="This document describes how to use the RDK's post effect classes in C/C++." />
  <meta property=”og:site_name” content="developer.rhino3d.com"/>
  <meta property=”og:image” content="http://developer.rhino3d.com/images/rhinodev-logo-unfurl.png"/>

  <!-- twitter card tags additive with the og: tags -->
  <meta name="twitter:domain" value="developer.rhino3d.com" />
  <meta name="twitter:title" value="RDK Post Effect Classes" />
  <meta name="twitter:description" value="This document describes how to use the RDK's post effect classes in C/C++." />
  
    <meta name="twitter:image" content="http://developer.rhino3d.com/images/rhinodev-logo-unfurl.png" />
  
  <meta name="twitter:url" value="http://developer.rhino3d.com" />
  
  <meta name="twitter:label1" value="Platform(s)" />
  <meta name="twitter:data1" value="Windows" />
  
  
  <meta name="twitter:label2" value="Language(s)" />
  <meta name="twitter:data2" value="C/C++" />
  

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/vbnet.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/yaml.min.js"></script>
  <script src="/6/node_modules/highlightjs-line-numbers.js/dist/highlightjs-line-numbers.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  <script>hljs.initLineNumbersOnLoad();</script>

  <!-- Overridden theme -->
  <link rel="stylesheet" href="/6/css/main.css">

  <!-- Latest compiled and minified CSS -->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

  <!-- Optional theme -->
  <!-- <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css" integrity="sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp" crossorigin="anonymous"> -->
  <!-- Bootstrap override -->
  <link rel="stylesheet" href="/6/css/bootstrap-override.css">

  <link rel="canonical" href="http://developer.rhino3d.com/6/guides/cpp/rdk-post-effects/">
  <link rel="alternate" type="application/rss+xml" title="Rhino Developer Docs" href="http://developer.rhino3d.com/6/feed.xml" />

  <link rel="shortcut icon" href="https://developer.rhino3d.com/favicon.ico?v=2" />
  <!-- Saving bookmarks to mobile devices -->
  <!-- For non-Retina (@1× display) iPhone, iPod Touch, and Android 2.1+ devices: -->
  <link rel="apple-touch-icon-precomposed" href="/6/images/apple-touch-icon-precomposed.png"><!-- 57×57px -->
  <!-- For the iPad mini and the first- and second-generation iPad (@1× display) on iOS ≤ 6: -->
  <link rel="apple-touch-icon-precomposed" sizes="72x72" href="/6/images/apple-touch-icon-72x72-precomposed.png">
  <!-- For the iPad mini and the first- and second-generation iPad (@1× display) on iOS ≥ 7: -->
  <link rel="apple-touch-icon-precomposed" sizes="76x76" href="/6/images/apple-touch-icon-76x76-precomposed.png">
  <!-- For iPhone with @2× display running iOS ≤ 6: -->
  <link rel="apple-touch-icon-precomposed" sizes="114x114" href="/6/images/apple-touch-icon-114x114-precomposed.png">
  <!-- For iPhone with @2× display running iOS ≥ 7: -->
  <link rel="apple-touch-icon-precomposed" sizes="120x120" href="/6/images/apple-touch-icon-120x120-precomposed.png">
  <!-- For iPad with @2× display running iOS ≤ 6: -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/6/images/apple-touch-icon-144x144-precomposed.png">
  <!-- For iPad with @2× display running iOS ≥ 7: -->
  <link rel="apple-touch-icon-precomposed" sizes="152x152" href="/6/images/apple-touch-icon-152x152-precomposed.png">
  <!-- For iPhone 6 Plus with @3× display: -->
  <link rel="apple-touch-icon-precomposed" sizes="180x180" href="/6/images/apple-touch-icon-180x180-precomposed.png">
  <!-- For Chrome for Android: -->
  <link rel="icon" sizes="192x192" href="/6/images/touch-icon-192x192.png">

  <!-- Diable crawling because this version is the nolonger the stable version -->
  <meta name="robots" content="noindex" />
</head>


  <body>

    <!-- Google Tag Manager **This belongs right after the <body> tag**-->
    <noscript>
        <iframe src="//www.googletagmanager.com/ns.html?id=GTM-MWMDKN"
        height="0" width="0" style="display:none;visibility:hidden"></iframe>
    </noscript>
    <script>
        (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
        })(window,document,'script','dataLayer','GTM-MWMDKN');
    </script>
    <!-- End Google Tag Manager -->


    

<!-- The following are "casts" from the string to number using math filters... -->



<!-- ...but we need to check to see if the original branches were numbers or not... -->









  <div class="version-banner version-banner-warning">

    
      
        
          <strong>WARNING:</strong> You're viewing the older <strong>Rhino 6</strong> version of this page! <a href="/guides/cpp/rdk-post-effects/">View the <strong>Rhino 7</strong> version instead.</a>
        
        
        
      
    
</div>

<!-- Check the version banner for broken links and remove the link if found -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
<!-- <script>
$(document).ready(function()
{
  var splitPath = window.location.pathname.split("/");
  var linkURL = "/5/" + splitPath.splice(1,splitPath.length-1).join("/");

  $.get(linkURL).fail(function ()
  {
    var $aTag = $("div.version-banner > a");
    $aTag.text("Looking for the older Rhino 5 site?");
    $aTag.attr("href", "/5/");
  });
});
</script> -->


    <div class="container">

      <header class="site-header">


    <a class="site-title" href="/6/"><img src="/6/images/rhinodevlogo148x128.png" alt="Rhino Developer Docs" height="48" width="56"></a><a class="site-title" href="/6/">Rhino Developer Docs</a>

    <nav class="site-nav">
      <img class="menu-icon" src="/6/images/gi.svg">
      
      <div class="trigger">
      	<!--<a class="page-link" href="/6/">Welcome</a>-->
        <!-- get current page title and "collection" to figure out which nav
             link should be "active" -->
        
        
        
        
          
            
              
                
              
            
          
        
          
            
              
                
              
            
          
        
          
            
              
                
              
            
          
        
          
            
              
                
              
            
          
        
          
            
              
                
              
            
          
        
          
            
              
                
              
            
          
        
          
            
              
                
              
            
          
        
          
            
              
                
              
            
          
        
          
            
              
                
              
            
          
        
          
            
              
                
              
            
          
        
          
            
              
                
              
            
          
        
          
            
              
                
              
            
          
        
          
            
              
                
              
            
          
        
          
            
              
                
              
            
          
        
          
            
              
                
              
            
          
        
          
        
          
            
              
            
          
        
          
            
              
                
                  
                    <a class="page-link active" href="/6/guides/">Guides</a>
                    
                  
              
            
          
        
          
            
              
                
                  
                    <a class="page-link" href="/6/api/">API</a>
                    
                  
              
            
          
        
          
            
              
                
                  
                    <a class="page-link" href="/6/samples/">Samples</a>
                    
                  
              
            
          
        
          
            
          
        
          
            
              
                
                  
                    <a class="page-link" href="/6/videos/">Videos</a>
                    
                  
              
            
          
        
        <a class="page-link" href="https://discourse.mcneel.com/c/rhino-developer">Forums</a>
        <!-- Google Search Engine -->
        <!-- TODO Move to this site back into the Mcneel search, or use a simple site only search for results -->
        <div id="sitesearch">
            <!-- CSE Search Box Begins  -->
            <form id="search-box" name="search-box" onsubmit="sitesearchFunction()" action="/6/search-results.html">
                <input id="searchtext" type="search" name="q" size="24" value="" placeholder="Search" />
                <input class="searchBox" type="submit" size="2" value=" " />
            </form>
			<script type="text/javascript">
			function sitesearchFunction(){
				var form_id = document.getElementById("search-box");
				var form_action = form_id.action;
                var form_sb = document.getElementById("searchtext");
				var query_src = form_sb.value + " site:developer.rhino3d.com";
				form_sb.value = query_src.toString();
			}
			</script>
<!-- Google CSE Search Box Ends -->
        </div>
        <!--End of Google Search Engine -->
      </div>
    </nav>

</header>


      <div class="page-content">
        <!--div class="wrapper"-->
          <div class="container-fluid">

<div class="row-fluid">
    <!--Nav Bar -->
    <nav class="col-xs-0 col-md-3 bs-docs-sidebar">
    <ul id="sidebar" class="nav nav-stacked fixed">
        <!-- Find the h2 group and any h3 subgroups -->
        

        
    </ul>
</nav>


    <!--Main Content -->
    <div class="col-xs-12 col-md-9">
      <!--<div class="post">-->

        <article class="post-content">

          <ol class="breadcrumb">
              
              
              
              <li><a href="/6/guides/cpp">C/C++</a></li>

              
                
                  <li class="active">RDK</li>
                
              
          </ol>

          <h1>RDK Post Effect Classes</h1>

          <p>
  <span class="guide_byline">
    
      
      by <a href="/6/authors/john_croudy">John Croudy</a> (Last modified: <a href="https://github.com/mcneel/developer-rhino3d-com/commits/6/_guide_topics/cpp/rdk-post-effects.md" target="_blank">11 Aug 2020</a>)
    
  </span>

</p>

          <p>This document describes how to use the RDK's post effect classes in C/C++.</p>

          <p>This is preliminary documentation. The functionality described below is not yet available.</p>

<h3 id="introduction">Introduction</h3>
<p>Starting with Rhino 7, the RDK includes a new post effect system which allows plug-in developers to create their own post effects. Although this was possible prior to Rhino 7, earlier versions required the post effects to apply changes to the final RGBA bitmap pixels. This meant that the post effects could only work on low dynamic range (8-bit) color components. Furthermore, all processing had to be done on the CPU which could be very slow for some effects. The new <em>post effect pipeline</em> allows post effects to process the original high dynamic range channel data and also allows this to be done on the <em>GPU</em> if so desired. CPU post effects are, of course, still supported.</p>

<h3 id="the-post-effect-pipeline">The Post Effect pipeline</h3>
<p>The new post effect system operates as a pipeline. The post effects selected by the user are run one after the other. The process begins with the rendered image which exists as a set of channels in the frame buffer. As each effect runs, it processes the output of the previous one. Each post effect can operate on any of the available channels, such as RGBA, distance-from-camera, etc.</p>

<h3 id="post-effects">Post Effects</h3>
<p>A post effect is an object that runs in the Render Window to process the rendered frame buffer image and create a modified version of it. The RDK comes with several built-in post effects such as Fog and Depth-of-field. After rendering, the user can choose which post effects to apply and in what order to apply them. Every post effect has a <em>type</em> which determines when in the pipeline it is run. There are three of these types; <em>Early</em>, <em>Tone Mapping</em> and <em>Late</em> and the pipeline runs them in that order. Early post effects can operate on the original high dynamic range image. Tone mapping post effects perform <em>tone mapping</em> on the high dynamic range image to produce a low dynamic range image. The pipeline then runs a process which clamps the values in the RGBA channels to the range 0..1. Finally, the late post effects process this low dynamic range image to produce a final image which the pipeline converts to an 8-bit image. It is this final image which is displayed to the user in the Render Frame.</p>

<h3 id="writing-a-post-effect">Writing a Post Effect</h3>

<p>To write a post effect, a developer needs to create a subclass of one of the post effect base classes. Which base class you use depends on the type of your post effect.</p>

<p>If your post effect is intended to process the high dynamic range image, it must be derived from <code>CRhRdkNewEarlyPostEffectPlugIn</code>. If it is a tone mapper, it must be derived from <code>CRhRdkNewToneMappingPostEffectPlugIn</code>. If it operates on the low dynamic range image, it must be derived from <code>CRhRdkNewLatePostEffectPlugIn</code>.</p>

<p>The following is an example of an early post effect. All post effects follow this general style.</p>

<pre><code>class CExamplePostEffect : public CRhRdkEarlyPostEffect
{
public:
	CExamplePostEffect() { InternalResetToFactoryDefaults(); }

	static UUID Ident(void);

	virtual UUID Id(void) const override { return Ident(); }
	virtual ON_wString LocalName(void) const override;
	virtual unsigned int BitFlags(void) const override { uf_ExecuteForProductionRendering | uf_ExecuteForRealtimeRendering; }
	virtual void RequiredChannels(OUT ON_SimpleArray&lt;UUID&gt;&amp; aChan) const override;
	virtual bool Execute(IRhRdkNewPostEffectPipeline&amp; pipeline, const ON_4iRect&amp; rect) const override;
	virtual ExecuteWhileRenderingOptions GetExecuteWhileRenderingOption(void) const override { return ExecuteWhileRenderingOptions::Always; }
	virtual bool GetParameter(const wchar_t* wszName, OUT CRhRdkVariant&amp; vValue) const override;
	virtual bool SetParameter(const wchar_t* wszName, const CRhRdkVariant&amp; vValue) override;
	virtual bool ReadState(const IState&amp; state) override;
	virtual bool WriteState(IState&amp; state) const override;
	virtual void AddUISections(IRhRdkPostEffectUI&amp; ui) override;
	virtual void ResetToFactoryDefaults(void) override { InternalResetToFactoryDefaults(); }
	virtual bool DisplayHelp(void) const override { return false; }
	virtual bool CanDisplayHelp(void) const override { return false; }

private:
	void InternalResetToFactoryDefaults(void);
};
</code></pre>

<p>Each post effect has a unique id and a localized name which are returned by the <code>Id()</code> and <code>LocalName()</code> methods respectively. Next you specify a set of usage flags by implementing the <code>BitFlags()</code> method. This tells the RDK certain facts about the post effect, including under which circumstances the post effect should be executed, which is done by calling the <code>Execute()</code> method. The implementation of <code>Execute()</code> will be described in detail later. The pipeline executes some post effects while rendering is proceeding. To let it know if your post effect can support this, you implement <code>GetExecuteWhileRenderingOption()</code>. This can be one of the following:</p>

<ul>
  <li>‘Never’ means the post effect does not support execution while rendering.</li>
  <li>‘Always’ means the post effect supports execution while rendering.</li>
  <li>‘UseDelay’ means the post effect supports execution while rendering, but only after a delay the first time.</li>
</ul>

<p>Which of these you return depends on how time-consuming your post effect is and whether or not it requires the final rendered image to work properly. For example, the Fog effect works on single pixels and does not need the surrounding pixels in order to work. It is also quite fast. Therefore, it returns <code>ExecuteWhileRenderingOptions::Always</code>. On the other hand, the Watermark post effect needs to know how long the rendering took to complete, so it returns <code>ExecuteWhileRenderingOptions::Never</code> as it should only be run at the end, after rendering finishes.</p>

<h4 id="channels">Channels</h4>

<p>Your post effect will, of course, need to use existing channels to get its source data. You should implement <code>RequiredChannels()</code> to tell the RDK which channels it is planning to use. This information is needed if the user chooses ‘Automatic’ in the Render Channels section of the Rendering panel:</p>

<pre><code>void CExamplePostEffect::RequiredChannels(OUT ON_SimpleArray&lt;UUID&gt;&amp; aChan) const
{
	CRhRdkEarlyPostEffect::RequiredChannels(aChan); // Be sure to call the base class.

	aChan.Append(IRhRdkRenderWindow::chanRGBA);

	...
}
</code></pre>

<h4 id="parameters">Parameters</h4>

<p>If your post effect has options or <em>parameters</em> that the user can set, it will have some private members for these values. It must also implement the following methods:</p>

<ul>
  <li><code>GetParameter()</code> This is called by the user interface when it needs to display a value.</li>
  <li><code>SetParameter()</code> This is called by the user interface when the user changes a value.</li>
  <li><code>ReadState()</code> This is called when the post effect is read in during document loading.</li>
  <li><code>WriteState()</code> This is called when the post effect is written out during document saving.</li>
  <li><code>AddUISections()</code> This is called by the framework when the user interface is created. It allows the post effect to add sections (AKA roll-ups) to the user interface.</li>
  <li><code>ResetToFactoryDefaults()</code> This resets the settings to their initial default values.</li>
</ul>

<h4 id="help">Help</h4>

<p>Finally, your post effect can optionally provide a help page. If it does, it should implement <code>CanDisplayHelp()</code> to return <em>true</em>, and it must also implement <code>DisplayHelp()</code> to actually display the help page. Built-in post effects do this by opening a page from the Rhino documentation in the user’s web browser.</p>

<p>Once you have defined your post effect class, you must create a factory for it and register the factory with the RDK:</p>

<h4 id="registration">Registration</h4>

<pre><code>class CExamplePostEffectPlugInFactory : public CRhRdkNewPostEffectPlugInFactory
{
public:
	virtual IRhRdkNewPostEffectPlugIn* NewPostEffectPlugIn(void) const override { return new CExamplePostEffect; }
	virtual UUID PlugInId(void) const final override; // Return your render plug-in's id.
};
</code></pre>
<p>Registration of the factory is done in your override of <code>CRhRdkRenderPlugIn::RegisterExtensions()</code> as follows:</p>

<pre><code>void CMyRdkPlugIn::RegisterExtensions(void)
{
	...
	AddExtension(new CExamplePostEffectPlugInFactory);
	...
}
</code></pre>

<h4 id="implementation">Implementation</h4>

<p>The bulk of your post effect’s implementation will be in the <code>Execute()</code> method. In this example, we will assume you are writing a CPU-based post effect.</p>

<p>All post effects read channel data (pixels), do some calculations, and create new channel data. Very often, this will involve reading RGBA data, processing it, and writing RGBA data. The <code>Execute()</code> method has a parameter of type <code>IRhRdkNewPostEffectPipeline&amp;</code> and another of type <code>const ON_4iRect&amp;</code>. The post effect queries the pipeline for existing channels (the input), asks it to create new channels (the output) and then iterates over pixels within the specified rectangle to create the output form the input. Sometimes the rectangle will be for the whole rendering, and sometimes (during rendering) it will be small areas of the rendering. You don’t need to worry about this; you just need to process that exact rectangle of pixels.</p>

<p>In order to get input channels to process, the post effect must call <code>GetChannel()</code> specifying the channel identifier. Note that post effects are only allowed to access the color component channels (red, green, blue and alpha) by asking for the RGBA composite channel. Requests for the individual components (chanRed etc) are not allowed. So, to get the RGBA channel, the post effect does the following:</p>

<pre><code>	// Get the RGBA channel.
	const auto* pRGBA = pepl.GetChannelForRead(RW::chanRGBA, 0);
	if (nullptr == pRGBA)
		return false;
</code></pre>

<p>At this point you decide if you want to run on the CPU or the GPU and obtain the correct interface, as follows. We are running on the CPU, so we write:</p>

<pre><code>	const auto* pRGBA_CPU = pRGBA-&gt;CPU();
	if (nullptr == pRGBA_CPU)
		return false;

</code></pre>

<p>Having got the input channel, we now need to get a new output channel:</p>

<pre><code>	// Create a new RGBA channel.
	auto* pNewRGBA = pepl.GetChannelForWrite(RW::chanRGBA, 0);
	if (nullptr == pNewRGBA)
		return false;
</code></pre>

<p>We also need to get the CPU interface:</p>

<pre><code>	auto* pNewRGBA_CPU = pNewRGBA-&gt;CPU();
	if (nullptr == pNewRGBA_CPU)
		return false;
</code></pre>

<p>Now we are ready to enter the main pixel loop. Inside the loop, you read the input pixels by calling <code>pRGBA_CPU-&gt;GetValue()</code> or <code>pRGBA_CPU-&gt;GetValueEx()</code>. The latter is preferred because it’s faster than the former which was only retained for backward compatibility. You write the output pixels by calling <code>pNewRGBA_CPU-&gt;SetValue()</code>. The iteration is best done by iterating over y and then x. You should include a call to <code>IRhRdkNewPostEffectPipeline::ReportProgress()</code> in the <em>y</em> loop.</p>

<pre><code>	// Iterate over all the pixels in the area.
	for (int y = rect.top; y &lt; rect.bottom; y++)
	{
		for (int x = rect.left; x &lt; rect.right; x++)
		{
			float in[4];
			if (pRGBA_CPU-&gt;GetValueEx(x, y, in))
			{
				float out[4];
				// Do calculations and create 'out' from 'in'.
				pNewRGBA_CPU-&gt;SetValue(x, y, ComponentOrder::RGBA, out);
			}
		}

		// Report progress and abort if requested to.
		if (!pipeline.ReportProgress(y))
			break;
	}
</code></pre>

<p>Finally, the new channel must be committed. This causes the pipeline to replace the current version of the channel with your new version. If you don’t do this, you changes will be discarded.</p>
<pre><code>	// Commit the changes.
	pipeline.Commit(pNewRGBA);
</code></pre>

<p>Your changes are now in the pipeline and the next post effect to run will use your pixel data as its input, assuming it’s also working on RGBA data.</p>

<h4 id="cpu-vs-gpu-channels">CPU vs GPU channels.</h4>

<p>As mentioned above, post effects can run on the GPU instead of the CPU. By calling for the correct interface (<code>CPU()</code> or <code>GPU()</code>) you can transparently get access to the data you need. The pipeline takes care of managing the data and converting / moving it from CPU memory to GPU memory as needed. If several post effects run on the GPU, the data will be moved to the GPU and it will stay there while those post effects run. It will only be moved back to main CPU memory if a post effect calls <code>CPU()</code>.</p>

        </article>

      <!--</div>-->

    </div>
</div>
</div>

        <!--/div-->
      </div>

      <footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">

      
        <div class="row">
          <div class="col-md-4">

            <p class="text">
              
                
                Author: <a href="/6/authors/john_croudy">John Croudy</a>
              
            </p>
          </div>
          <div class="col-md-4 text-center">
            <span class="icon  icon--github">
              <svg viewBox="0 0 16 16">
                <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
              </svg>
            </span>
            <a href="https://github.com/mcneel/developer-rhino3d-com/blob/6/_guide_topics/cpp/rdk-post-effects.md" target="_blank">Edit page on GitHub</a>
          </div>
            <div class="col-md-4">
              <span class="pull-right">
                <span class="glyphicon glyphicon-cog"></span>&nbsp;<a href="/6/admin">Admin</a>
              </span>
            </div>
        </div>

        <div class="row text-center">
          © 1997 - 2021 Robert McNeel &amp; Associates<br/>
          <span class="glyphicon glyphicon-heart-empty"></span>&nbsp;<a href="/6/authors">Contributions welcome</a>
        </div>

      

    </div>

  </div>

  <script>
    if (navigator.appVersion.indexOf("Win")!=-1)
    {
      var body = document.getElementsByTagName("body");
      body[0].style.fontWeight = '400';
    }
  </script>

</footer>

    </div>

    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

    <!-- MathJax -->
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    <script type="text/javascript">
    $('body').scrollspy({
        target: '.bs-docs-sidebar',
        offset: 150 /* fixed header is about 40px high */
    });
    </script>
  </body>
</html>
